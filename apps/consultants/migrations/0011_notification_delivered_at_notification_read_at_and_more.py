# Generated by Django 5.2.6 on 2025-10-13 09:28

import datetime

import django.utils.timezone
from django.conf import settings
from django.db import migrations, models
from django.db.models import Count


class Migration(migrations.Migration):

    dependencies = [
        ("consultants", "0010_consultant_consultant_type"),
        ("decisions", "0001_initial"),
        ("certificates", "0002_initial"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]


def _status_rank(status: str) -> int:
    status_priority = {
        "rejected": 0,
        "draft": 1,
        "incomplete": 2,
        "submitted": 3,
        "vetted": 4,
        "approved": 5,
    }
    return status_priority.get(status, -1)


def _timestamp(value):
    if value is None:
        return 0
    if isinstance(value, datetime.datetime):
        try:
            return value.timestamp()
        except Exception:  # pragma: no cover - defensive fallback
            # ``timestamp`` can raise for values before the epoch on some
            # platforms, so normalise manually.
            if value.tzinfo is None:
                aware = value.replace(tzinfo=datetime.timezone.utc)
            else:
                aware = value.astimezone(datetime.timezone.utc)
            return (aware - datetime.datetime(1970, 1, 1, tzinfo=datetime.timezone.utc)).total_seconds()
    return value


def _select_primary(candidates):
    def sort_key(instance):
        return (
            _status_rank(getattr(instance, "status", "")),
            1 if getattr(instance, "certificate_generated_at", None) else 0,
            1 if getattr(instance, "submitted_at", None) else 0,
            _timestamp(getattr(instance, "submitted_at", None)),
            _timestamp(getattr(instance, "updated_at", None)),
            -instance.pk,
        )

    return sorted(candidates, key=sort_key, reverse=True)[0]


def _merge_consultant(primary, duplicate):
    fields_to_copy = [
        "submitted_at",
        "certificate_generated_at",
        "certificate_expires_at",
        "certificate_pdf",
        "rejection_letter",
        "rejection_letter_generated_at",
        "staff_comment",
    ]
    updated_fields = []

    if _status_rank(getattr(duplicate, "status", "")) > _status_rank(getattr(primary, "status", "")):
        primary.status = duplicate.status
        updated_fields.append("status")

    if getattr(duplicate, "is_seen_by_staff", False) and not getattr(primary, "is_seen_by_staff", False):
        primary.is_seen_by_staff = True
        updated_fields.append("is_seen_by_staff")

    for field in fields_to_copy:
        primary_value = getattr(primary, field, None)
        duplicate_value = getattr(duplicate, field, None)
        if not primary_value and duplicate_value:
            setattr(primary, field, duplicate_value)
            updated_fields.append(field)

    if updated_fields:
        primary.save(update_fields=updated_fields)


def _reassign_related(apps, primary, duplicate):
    related_models = (
        ("decisions", "ApplicationAction", "consultant"),
        ("certificates", "CertificateRenewal", "consultant"),
    )

    for app_label, model_name, field_name in related_models:
        Model = apps.get_model(app_label, model_name)
        Model.objects.filter(**{field_name: duplicate}).update(**{field_name: primary})


def _dedupe_group(apps, queryset):
    candidates = list(queryset)
    if len(candidates) <= 1:
        return

    primary = _select_primary(candidates)
    for duplicate in candidates:
        if duplicate.pk == primary.pk:
            continue

        _merge_consultant(primary, duplicate)
        _reassign_related(apps, primary, duplicate)
        duplicate.delete()


def deduplicate_consultants(apps, schema_editor):
    Consultant = apps.get_model("consultants", "Consultant")

    for fields in (("email", "nationality"), ("user_id",), ("id_number",)):
        duplicates = (
            Consultant.objects.values(*fields)
            .order_by()
            .annotate(total=Count("id"))
            .filter(total__gt=1)
        )

        for duplicate_values in duplicates:
            filters = {field: duplicate_values[field] for field in fields}
            queryset = Consultant.objects.filter(**filters).order_by("-updated_at", "-pk")
            _dedupe_group(apps, queryset)

    operations = [
        migrations.AddField(
            model_name="notification",
            name="delivered_at",
            field=models.DateTimeField(
                default=django.utils.timezone.now, editable=False
            ),
        ),
        migrations.AddField(
            model_name="notification",
            name="read_at",
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.RunPython(deduplicate_consultants, migrations.RunPython.noop),
        migrations.AddConstraint(
            model_name="consultant",
            constraint=models.UniqueConstraint(
                fields=("user",), name="consultants_unique_application_per_user"
            ),
        ),
        migrations.AddConstraint(
            model_name="consultant",
            constraint=models.UniqueConstraint(
                fields=("id_number",), name="consultants_unique_id_number"
            ),
        ),
        migrations.AddConstraint(
            model_name="consultant",
            constraint=models.UniqueConstraint(
                fields=("email", "nationality"),
                name="consultants_unique_email_per_nationality",
            ),
        ),
    ]
