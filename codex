#!/usr/bin/env python3
"""Codex automation CLI.

This lightweight CLI provides a local fallback implementation of the
``codex review`` command so developers can run automated hygiene checks
without relying on the upstream Codex service.  The goal is to emulate the
``codex review --repo <path> --apply-fixes`` workflow that external tooling
expects while remaining self-contained within this repository.
"""
from __future__ import annotations

import argparse
import py_compile
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Sequence

EXCLUDED_DIRS: Sequence[str] = (
    ".git",
    "venv",
    ".venv",
    "node_modules",
    "__pycache__",
    "results",
)

PYTHON_EXTENSIONS: Sequence[str] = (".py", ".pyi")


@dataclass
class ReviewResult:
    repo: Path
    applied_fixes: List[Path]
    compile_success: bool
    compile_output: str
    python_file_count: int
    total_python_lines: int
    git_status: str


def parse_args(argv: Sequence[str]) -> argparse.Namespace:
    """Build and parse CLI arguments for the Codex automation helper."""

    parser = argparse.ArgumentParser(
        prog="codex", formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    review_parser = subparsers.add_parser(
        "review",
        help="Run local repository checks and optional auto-fixes.",
    )
    review_parser.add_argument(
        "--repo",
        default=Path.cwd(),
        type=Path,
        help="Path to the repository to review (defaults to current directory).",
    )
    review_parser.add_argument(
        "--apply-fixes",
        action="store_true",
        help="Apply safe automated fixes (currently trims trailing whitespace).",
    )
    review_parser.add_argument(
        "--no-compile",
        action="store_true",
        help="Skip the compileall check (useful for non-Python projects).",
    )

    return parser.parse_args(list(argv))


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv or sys.argv[1:])

    if args.command == "review":
        result = run_review(args.repo, apply_fixes=args.apply_fixes, skip_compile=args.no_compile)
        print_review(result)
        return 0 if result.compile_success or args.no_compile else 1

    print(f"Unknown command: {args.command}", file=sys.stderr)
    return 2


def run_review(repo_path: Path, *, apply_fixes: bool, skip_compile: bool) -> ReviewResult:
    """Run repository checks and return a summary of the results."""

    repo = repo_path.expanduser().resolve()
    if not repo.exists() or not repo.is_dir():
        raise SystemExit(f"âŒ Repository path does not exist: {repo}")

    python_files = list(iter_python_files(repo))
    applied_fixes: List[Path] = []

    if apply_fixes:
        applied_fixes = apply_trailing_whitespace_fix(python_files)

    compile_success = True
    compile_output = ""
    if not skip_compile and python_files:
        compile_success, compile_output = compile_python_files(python_files)

    total_lines = sum(count_lines(path) for path in python_files)
    status_output = run_git_status(repo)

    return ReviewResult(
        repo=repo,
        applied_fixes=applied_fixes,
        compile_success=compile_success,
        compile_output=compile_output,
        python_file_count=len(python_files),
        total_python_lines=total_lines,
        git_status=status_output,
    )


def iter_python_files(repo: Path) -> Iterable[Path]:
    """Yield Python files under ``repo`` while honoring the excluded directories."""

    for path in repo.rglob("*"):
        if not path.is_file():
            continue
        if path.suffix not in PYTHON_EXTENSIONS:
            continue
        try:
            relative_parts = path.relative_to(repo).parts
        except ValueError:
            relative_parts = path.parts
        if any(part in EXCLUDED_DIRS for part in relative_parts):
            continue
        yield path


def apply_trailing_whitespace_fix(files: Iterable[Path]) -> List[Path]:
    """Trim trailing whitespace across provided files and return the modified paths."""

    changed_files: List[Path] = []
    for path in files:
        try:
            original = path.read_text()
        except UnicodeDecodeError:
            # Skip binary or non-text files.
            continue
        stripped_lines = [line.rstrip() for line in original.splitlines()]
        new_text = "\n".join(stripped_lines)
        if stripped_lines:
            new_text += "\n"
        if new_text != original:
            path.write_text(new_text, encoding="utf-8")
            changed_files.append(path)
    return changed_files


def compile_python_files(files: Iterable[Path]) -> tuple[bool, str]:
    """Compile provided Python files to bytecode, returning success and diagnostics."""

    failures: list[str] = []
    for path in files:
        try:
            py_compile.compile(str(path), doraise=True)
        except (py_compile.PyCompileError, SyntaxError) as exc:  # pragma: no cover - exercised in tests
            failures.append(f"{path}: {exc}")

    if failures:
        return False, "\n".join(failures)
    return True, ""


def count_lines(path: Path) -> int:
    """Count the number of lines in a text file, ignoring binary files."""

    try:
        with path.open("r", encoding="utf-8") as fh:
            return sum(1 for _ in fh)
    except UnicodeDecodeError:
        return 0


def run_git_status(repo: Path) -> str:
    """Return a concise git status for the repository, handling common errors."""

    try:
        process = subprocess.run(
            ["git", "-C", str(repo), "status", "--short"],
            capture_output=True,
            text=True,
            check=False,
        )
    except FileNotFoundError:
        return "git executable not available."
    if process.returncode != 0:
        return process.stderr.strip() or process.stdout.strip()
    return process.stdout.strip() or "Working tree clean."


def print_review(result: ReviewResult) -> None:
    print("ğŸ§  Codex Local Review")
    print(f"ğŸ“ Repository: {result.repo}")
    print(f"ğŸ Python files: {result.python_file_count}")
    print(f"âœ³ï¸  Total Python lines: {result.total_python_lines}")

    if result.applied_fixes:
        print("ğŸ› ï¸  Applied trailing whitespace fixes to:")
        for path in result.applied_fixes:
            print(f"   â€¢ {path.relative_to(result.repo)}")
    else:
        print("ğŸ› ï¸  No fixes applied.")

    if result.python_file_count == 0:
        print("â„¹ï¸  No Python files detected; compile step skipped.")
    elif result.compile_output:
        header = "âœ… Python bytecode compilation succeeded" if result.compile_success else "âŒ Python bytecode compilation failed"
        print(header)
        print(result.compile_output)
    else:
        if result.compile_success:
            print("âœ… Python bytecode compilation succeeded.")
        else:
            print("âŒ Python bytecode compilation failed with no diagnostic output.")

    print("ğŸ“„ Git status:")
    print(result.git_status or "Working tree clean.")


if __name__ == "__main__":
    raise SystemExit(main())
